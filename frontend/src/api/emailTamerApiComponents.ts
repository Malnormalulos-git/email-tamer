/**
 * Generated by @openapi-codegen
 *
 * @version v1
 */
import * as reactQuery from '@tanstack/react-query';

import {
    useEmailTamerApiContext,
    EmailTamerApiContext,
    queryKeyFn,
} from './emailTamerApiContext';
import { deepMerge } from './emailTamerApiUtils';

import { emailTamerApiFetch } from './emailTamerApiFetcher';

import type * as Fetcher from './emailTamerApiFetcher';
import type * as Schemas from './emailTamerApiSchemas';

type QueryFnOptions = {
  signal?: AbortController['signal'];
};

export type RegisterError = Fetcher.ErrorWrapper<undefined>;

export type RegisterVariables = {
  body?: Schemas.CreateUserDto;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchRegister = (
    variables: RegisterVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    undefined,
    RegisterError,
    Schemas.CreateUserDto,
    {},
    {},
    {}
  >({ url: '/api/auth/register', method: 'post', ...variables, signal });

export const useRegister = (
    options?: Omit<
    reactQuery.UseMutationOptions<undefined, RegisterError, RegisterVariables>,
    'mutationFn'
  >,
) => {
    const { fetcherOptions } = useEmailTamerApiContext();
    return reactQuery.useMutation<undefined, RegisterError, RegisterVariables>({
        mutationFn: (variables: RegisterVariables) =>
            fetchRegister(deepMerge(fetcherOptions, variables)),
        ...options,
    });
};

export type LoginError = Fetcher.ErrorWrapper<undefined>;

export type LoginVariables = {
  body?: Schemas.LogInDto;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) =>
    emailTamerApiFetch<
    Schemas.AuthResponseDto,
    LoginError,
    Schemas.LogInDto,
    {},
    {},
    {}
  >({ url: '/api/auth/login', method: 'post', ...variables, signal });

export const useLogin = (
    options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AuthResponseDto,
      LoginError,
      LoginVariables
    >,
    'mutationFn'
  >,
) => {
    const { fetcherOptions } = useEmailTamerApiContext();
    return reactQuery.useMutation<
    Schemas.AuthResponseDto,
    LoginError,
    LoginVariables
  >({
      mutationFn: (variables: LoginVariables) =>
          fetchLogin(deepMerge(fetcherOptions, variables)),
      ...options,
  });
};

export type GetCurrentUserError = Fetcher.ErrorWrapper<undefined>;

export type GetCurrentUserVariables = EmailTamerApiContext['fetcherOptions'];

export const fetchGetCurrentUser = (
    variables: GetCurrentUserVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    Schemas.UserDto,
    GetCurrentUserError,
    undefined,
    {},
    {},
    {}
  >({ url: '/api/auth/user', method: 'get', ...variables, signal });

export function getCurrentUserQuery(variables: GetCurrentUserVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UserDto>;
};

export function getCurrentUserQuery(
  variables: GetCurrentUserVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.UserDto>)
    | reactQuery.SkipToken;
};

export function getCurrentUserQuery(
    variables: GetCurrentUserVariables | reactQuery.SkipToken,
) {
    return {
        queryKey: queryKeyFn({
            path: '/api/auth/user',
            operationId: 'getCurrentUser',
            variables,
        }),
        queryFn:
      variables === reactQuery.skipToken
          ? reactQuery.skipToken
          : ({ signal }: QueryFnOptions) =>
              fetchGetCurrentUser(variables, signal),
    };
}

export const useSuspenseGetCurrentUser = <TData = Schemas.UserDto,>(
    variables: GetCurrentUserVariables,
    options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserDto, GetCurrentUserError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useSuspenseQuery<
    Schemas.UserDto,
    GetCurrentUserError,
    TData
  >({
      ...getCurrentUserQuery(deepMerge(fetcherOptions, variables)),
      ...options,
      ...queryOptions,
  });
};

export const useGetCurrentUser = <TData = Schemas.UserDto,>(
    variables: GetCurrentUserVariables | reactQuery.SkipToken,
    options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserDto, GetCurrentUserError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useQuery<Schemas.UserDto, GetCurrentUserError, TData>({
        ...getCurrentUserQuery(
            variables === reactQuery.skipToken
                ? variables
                : deepMerge(fetcherOptions, variables),
        ),
        ...options,
        ...queryOptions,
    });
};

export type BackUpEmailBoxMessagesPathParams = {
  /**
   * @format uuid
   */
  id: string;
};

export type BackUpEmailBoxMessagesError = Fetcher.ErrorWrapper<undefined>;

export type BackUpEmailBoxMessagesVariables = {
  pathParams: BackUpEmailBoxMessagesPathParams;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchBackUpEmailBoxMessages = (
    variables: BackUpEmailBoxMessagesVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    undefined,
    BackUpEmailBoxMessagesError,
    undefined,
    {},
    {},
    BackUpEmailBoxMessagesPathParams
  >({ url: '/api/backup/{id}', method: 'post', ...variables, signal });

export const useBackUpEmailBoxMessages = (
    options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      BackUpEmailBoxMessagesError,
      BackUpEmailBoxMessagesVariables
    >,
    'mutationFn'
  >,
) => {
    const { fetcherOptions } = useEmailTamerApiContext();
    return reactQuery.useMutation<
    undefined,
    BackUpEmailBoxMessagesError,
    BackUpEmailBoxMessagesVariables
  >({
      mutationFn: (variables: BackUpEmailBoxMessagesVariables) =>
          fetchBackUpEmailBoxMessages(deepMerge(fetcherOptions, variables)),
      ...options,
  });
};

export type BackUpEmailBoxesMessagesError = Fetcher.ErrorWrapper<undefined>;

export type BackUpEmailBoxesMessagesVariables =
  EmailTamerApiContext['fetcherOptions'];

export const fetchBackUpEmailBoxesMessages = (
    variables: BackUpEmailBoxesMessagesVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    undefined,
    BackUpEmailBoxesMessagesError,
    undefined,
    {},
    {},
    {}
  >({ url: '/api/backup', method: 'post', ...variables, signal });

export const useBackUpEmailBoxesMessages = (
    options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      BackUpEmailBoxesMessagesError,
      BackUpEmailBoxesMessagesVariables
    >,
    'mutationFn'
  >,
) => {
    const { fetcherOptions } = useEmailTamerApiContext();
    return reactQuery.useMutation<
    undefined,
    BackUpEmailBoxesMessagesError,
    BackUpEmailBoxesMessagesVariables
  >({
      mutationFn: (variables: BackUpEmailBoxesMessagesVariables) =>
          fetchBackUpEmailBoxesMessages(deepMerge(fetcherOptions, variables)),
      ...options,
  });
};

export type GetMessagesThreadsQueryParams = {
  /**
   * @format uuid
   */
  folderId?: string;
  emailBoxesIds?: string;
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  size?: number;
};

export type GetMessagesThreadsError = Fetcher.ErrorWrapper<undefined>;

export type GetMessagesThreadsVariables = {
  queryParams?: GetMessagesThreadsQueryParams;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchGetMessagesThreads = (
    variables: GetMessagesThreadsVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    Schemas.MessagesThreadShortDtoPagedResult,
    GetMessagesThreadsError,
    undefined,
    {},
    GetMessagesThreadsQueryParams,
    {}
  >({ url: '/api/backup', method: 'get', ...variables, signal });

export function getMessagesThreadsQuery(
  variables: GetMessagesThreadsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.MessagesThreadShortDtoPagedResult>;
};

export function getMessagesThreadsQuery(
  variables: GetMessagesThreadsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.MessagesThreadShortDtoPagedResult>)
    | reactQuery.SkipToken;
};

export function getMessagesThreadsQuery(
    variables: GetMessagesThreadsVariables | reactQuery.SkipToken,
) {
    return {
        queryKey: queryKeyFn({
            path: '/api/backup',
            operationId: 'getMessagesThreads',
            variables,
        }),
        queryFn:
      variables === reactQuery.skipToken
          ? reactQuery.skipToken
          : ({ signal }: QueryFnOptions) =>
              fetchGetMessagesThreads(variables, signal),
    };
}

export const useSuspenseGetMessagesThreads = <
  TData = Schemas.MessagesThreadShortDtoPagedResult,
>(
        variables: GetMessagesThreadsVariables,
        options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MessagesThreadShortDtoPagedResult,
      GetMessagesThreadsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
    ) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useSuspenseQuery<
    Schemas.MessagesThreadShortDtoPagedResult,
    GetMessagesThreadsError,
    TData
  >({
      ...getMessagesThreadsQuery(deepMerge(fetcherOptions, variables)),
      ...options,
      ...queryOptions,
  });
};

export const useGetMessagesThreads = <
  TData = Schemas.MessagesThreadShortDtoPagedResult,
>(
        variables: GetMessagesThreadsVariables | reactQuery.SkipToken,
        options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MessagesThreadShortDtoPagedResult,
      GetMessagesThreadsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
    ) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useQuery<
    Schemas.MessagesThreadShortDtoPagedResult,
    GetMessagesThreadsError,
    TData
  >({
      ...getMessagesThreadsQuery(
          variables === reactQuery.skipToken
              ? variables
              : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
  });
};

export type GetMessageDetailsError = Fetcher.ErrorWrapper<undefined>;

export type GetMessageDetailsVariables = {
  body?: Schemas.GetMessageDetailsDto;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchGetMessageDetails = (
    variables: GetMessageDetailsVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    Schemas.MessageDetailsDto,
    GetMessageDetailsError,
    Schemas.GetMessageDetailsDto,
    {},
    {},
    {}
  >({ url: '/api/backup/message', method: 'get', ...variables, signal });

export function getMessageDetailsQuery(variables: GetMessageDetailsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.MessageDetailsDto>;
};

export function getMessageDetailsQuery(
  variables: GetMessageDetailsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.MessageDetailsDto>)
    | reactQuery.SkipToken;
};

export function getMessageDetailsQuery(
    variables: GetMessageDetailsVariables | reactQuery.SkipToken,
) {
    return {
        queryKey: queryKeyFn({
            path: '/api/backup/message',
            operationId: 'getMessageDetails',
            variables,
        }),
        queryFn:
      variables === reactQuery.skipToken
          ? reactQuery.skipToken
          : ({ signal }: QueryFnOptions) =>
              fetchGetMessageDetails(variables, signal),
    };
}

export const useSuspenseGetMessageDetails = <
  TData = Schemas.MessageDetailsDto,
>(
        variables: GetMessageDetailsVariables,
        options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MessageDetailsDto,
      GetMessageDetailsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
    ) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useSuspenseQuery<
    Schemas.MessageDetailsDto,
    GetMessageDetailsError,
    TData
  >({
      ...getMessageDetailsQuery(deepMerge(fetcherOptions, variables)),
      ...options,
      ...queryOptions,
  });
};

export const useGetMessageDetails = <TData = Schemas.MessageDetailsDto,>(
    variables: GetMessageDetailsVariables | reactQuery.SkipToken,
    options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MessageDetailsDto,
      GetMessageDetailsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useQuery<
    Schemas.MessageDetailsDto,
    GetMessageDetailsError,
    TData
  >({
      ...getMessageDetailsQuery(
          variables === reactQuery.skipToken
              ? variables
              : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
  });
};

export type GetMessageAttachmentError = Fetcher.ErrorWrapper<undefined>;

export type GetMessageAttachmentVariables = {
  body?: Schemas.GetMessageAttachmentDto;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchGetMessageAttachment = (
    variables: GetMessageAttachmentVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    Blob,
    GetMessageAttachmentError,
    Schemas.GetMessageAttachmentDto,
    {},
    {},
    {}
  >({ url: '/api/backup/attachment', method: 'get', ...variables, signal });

export function getMessageAttachmentQuery(
  variables: GetMessageAttachmentVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Blob>;
};

export function getMessageAttachmentQuery(
  variables: GetMessageAttachmentVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<Blob>) | reactQuery.SkipToken;
};

export function getMessageAttachmentQuery(
    variables: GetMessageAttachmentVariables | reactQuery.SkipToken,
) {
    return {
        queryKey: queryKeyFn({
            path: '/api/backup/attachment',
            operationId: 'getMessageAttachment',
            variables,
        }),
        queryFn:
      variables === reactQuery.skipToken
          ? reactQuery.skipToken
          : ({ signal }: QueryFnOptions) =>
              fetchGetMessageAttachment(variables, signal),
    };
}

export const useSuspenseGetMessageAttachment = <TData = Blob,>(
    variables: GetMessageAttachmentVariables,
    options?: Omit<
    reactQuery.UseQueryOptions<Blob, GetMessageAttachmentError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useSuspenseQuery<Blob, GetMessageAttachmentError, TData>({
        ...getMessageAttachmentQuery(deepMerge(fetcherOptions, variables)),
        ...options,
        ...queryOptions,
    });
};

export const useGetMessageAttachment = <TData = Blob,>(
    variables: GetMessageAttachmentVariables | reactQuery.SkipToken,
    options?: Omit<
    reactQuery.UseQueryOptions<Blob, GetMessageAttachmentError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useQuery<Blob, GetMessageAttachmentError, TData>({
        ...getMessageAttachmentQuery(
            variables === reactQuery.skipToken
                ? variables
                : deepMerge(fetcherOptions, variables),
        ),
        ...options,
        ...queryOptions,
    });
};

export type GetMessagesThreadError = Fetcher.ErrorWrapper<undefined>;

export type GetMessagesThreadVariables = {
  body?: Schemas.GetMessageDetailsDto;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchGetMessagesThread = (
    variables: GetMessagesThreadVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    Schemas.MessagesThreadDto,
    GetMessagesThreadError,
    Schemas.GetMessageDetailsDto,
    {},
    {},
    {}
  >({ url: '/api/backup/thread', method: 'get', ...variables, signal });

export function getMessagesThreadQuery(variables: GetMessagesThreadVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.MessagesThreadDto>;
};

export function getMessagesThreadQuery(
  variables: GetMessagesThreadVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.MessagesThreadDto>)
    | reactQuery.SkipToken;
};

export function getMessagesThreadQuery(
    variables: GetMessagesThreadVariables | reactQuery.SkipToken,
) {
    return {
        queryKey: queryKeyFn({
            path: '/api/backup/thread',
            operationId: 'getMessagesThread',
            variables,
        }),
        queryFn:
      variables === reactQuery.skipToken
          ? reactQuery.skipToken
          : ({ signal }: QueryFnOptions) =>
              fetchGetMessagesThread(variables, signal),
    };
}

export const useSuspenseGetMessagesThread = <
  TData = Schemas.MessagesThreadDto,
>(
        variables: GetMessagesThreadVariables,
        options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MessagesThreadDto,
      GetMessagesThreadError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
    ) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useSuspenseQuery<
    Schemas.MessagesThreadDto,
    GetMessagesThreadError,
    TData
  >({
      ...getMessagesThreadQuery(deepMerge(fetcherOptions, variables)),
      ...options,
      ...queryOptions,
  });
};

export const useGetMessagesThread = <TData = Schemas.MessagesThreadDto,>(
    variables: GetMessagesThreadVariables | reactQuery.SkipToken,
    options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MessagesThreadDto,
      GetMessagesThreadError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useQuery<
    Schemas.MessagesThreadDto,
    GetMessagesThreadError,
    TData
  >({
      ...getMessagesThreadQuery(
          variables === reactQuery.skipToken
              ? variables
              : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
  });
};

export type GetFoldersError = Fetcher.ErrorWrapper<undefined>;

export type GetFoldersResponse = Schemas.FolderDto[];

export type GetFoldersVariables = EmailTamerApiContext['fetcherOptions'];

export const fetchGetFolders = (
    variables: GetFoldersVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    GetFoldersResponse,
    GetFoldersError,
    undefined,
    {},
    {},
    {}
  >({ url: '/api/backup/folders', method: 'get', ...variables, signal });

export function getFoldersQuery(variables: GetFoldersVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetFoldersResponse>;
};

export function getFoldersQuery(
  variables: GetFoldersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetFoldersResponse>)
    | reactQuery.SkipToken;
};

export function getFoldersQuery(
    variables: GetFoldersVariables | reactQuery.SkipToken,
) {
    return {
        queryKey: queryKeyFn({
            path: '/api/backup/folders',
            operationId: 'getFolders',
            variables,
        }),
        queryFn:
      variables === reactQuery.skipToken
          ? reactQuery.skipToken
          : ({ signal }: QueryFnOptions) => fetchGetFolders(variables, signal),
    };
}

export const useSuspenseGetFolders = <TData = GetFoldersResponse,>(
    variables: GetFoldersVariables,
    options?: Omit<
    reactQuery.UseQueryOptions<GetFoldersResponse, GetFoldersError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useSuspenseQuery<
    GetFoldersResponse,
    GetFoldersError,
    TData
  >({
      ...getFoldersQuery(deepMerge(fetcherOptions, variables)),
      ...options,
      ...queryOptions,
  });
};

export const useGetFolders = <TData = GetFoldersResponse,>(
    variables: GetFoldersVariables | reactQuery.SkipToken,
    options?: Omit<
    reactQuery.UseQueryOptions<GetFoldersResponse, GetFoldersError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useQuery<GetFoldersResponse, GetFoldersError, TData>({
        ...getFoldersQuery(
            variables === reactQuery.skipToken
                ? variables
                : deepMerge(fetcherOptions, variables),
        ),
        ...options,
        ...queryOptions,
    });
};

export type CreateEmailBoxError = Fetcher.ErrorWrapper<undefined>;

export type CreateEmailBoxVariables = {
  body?: Schemas.CreateEmailBoxDto;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchCreateEmailBox = (
    variables: CreateEmailBoxVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    undefined,
    CreateEmailBoxError,
    Schemas.CreateEmailBoxDto,
    {},
    {},
    {}
  >({ url: '/api/emailBoxes', method: 'post', ...variables, signal });

export const useCreateEmailBox = (
    options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      CreateEmailBoxError,
      CreateEmailBoxVariables
    >,
    'mutationFn'
  >,
) => {
    const { fetcherOptions } = useEmailTamerApiContext();
    return reactQuery.useMutation<
    undefined,
    CreateEmailBoxError,
    CreateEmailBoxVariables
  >({
      mutationFn: (variables: CreateEmailBoxVariables) =>
          fetchCreateEmailBox(deepMerge(fetcherOptions, variables)),
      ...options,
  });
};

export type GetEmailBoxesError = Fetcher.ErrorWrapper<undefined>;

export type GetEmailBoxesResponse = Schemas.EmailBoxDto[];

export type GetEmailBoxesVariables = EmailTamerApiContext['fetcherOptions'];

export const fetchGetEmailBoxes = (
    variables: GetEmailBoxesVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    GetEmailBoxesResponse,
    GetEmailBoxesError,
    undefined,
    {},
    {},
    {}
  >({ url: '/api/emailBoxes', method: 'get', ...variables, signal });

export function getEmailBoxesQuery(variables: GetEmailBoxesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetEmailBoxesResponse>;
};

export function getEmailBoxesQuery(
  variables: GetEmailBoxesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetEmailBoxesResponse>)
    | reactQuery.SkipToken;
};

export function getEmailBoxesQuery(
    variables: GetEmailBoxesVariables | reactQuery.SkipToken,
) {
    return {
        queryKey: queryKeyFn({
            path: '/api/emailBoxes',
            operationId: 'getEmailBoxes',
            variables,
        }),
        queryFn:
      variables === reactQuery.skipToken
          ? reactQuery.skipToken
          : ({ signal }: QueryFnOptions) => fetchGetEmailBoxes(variables, signal),
    };
}

export const useSuspenseGetEmailBoxes = <TData = GetEmailBoxesResponse,>(
    variables: GetEmailBoxesVariables,
    options?: Omit<
    reactQuery.UseQueryOptions<
      GetEmailBoxesResponse,
      GetEmailBoxesError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useSuspenseQuery<
    GetEmailBoxesResponse,
    GetEmailBoxesError,
    TData
  >({
      ...getEmailBoxesQuery(deepMerge(fetcherOptions, variables)),
      ...options,
      ...queryOptions,
  });
};

export const useGetEmailBoxes = <TData = GetEmailBoxesResponse,>(
    variables: GetEmailBoxesVariables | reactQuery.SkipToken,
    options?: Omit<
    reactQuery.UseQueryOptions<
      GetEmailBoxesResponse,
      GetEmailBoxesError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useQuery<GetEmailBoxesResponse, GetEmailBoxesError, TData>({
        ...getEmailBoxesQuery(
            variables === reactQuery.skipToken
                ? variables
                : deepMerge(fetcherOptions, variables),
        ),
        ...options,
        ...queryOptions,
    });
};

export type EditEmailBoxError = Fetcher.ErrorWrapper<undefined>;

export type EditEmailBoxVariables = {
  body?: Schemas.EditEmailBoxDto;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchEditEmailBox = (
    variables: EditEmailBoxVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    undefined,
    EditEmailBoxError,
    Schemas.EditEmailBoxDto,
    {},
    {},
    {}
  >({ url: '/api/emailBoxes', method: 'patch', ...variables, signal });

export const useEditEmailBox = (
    options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      EditEmailBoxError,
      EditEmailBoxVariables
    >,
    'mutationFn'
  >,
) => {
    const { fetcherOptions } = useEmailTamerApiContext();
    return reactQuery.useMutation<
    undefined,
    EditEmailBoxError,
    EditEmailBoxVariables
  >({
      mutationFn: (variables: EditEmailBoxVariables) =>
          fetchEditEmailBox(deepMerge(fetcherOptions, variables)),
      ...options,
  });
};

export type GetEmailBoxDetailsPathParams = {
  /**
   * @format uuid
   */
  id: string;
};

export type GetEmailBoxDetailsError = Fetcher.ErrorWrapper<undefined>;

export type GetEmailBoxDetailsVariables = {
  pathParams: GetEmailBoxDetailsPathParams;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchGetEmailBoxDetails = (
    variables: GetEmailBoxDetailsVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    Schemas.EmailBoxDetailsDto,
    GetEmailBoxDetailsError,
    undefined,
    {},
    {},
    GetEmailBoxDetailsPathParams
  >({ url: '/api/emailBoxes/{id}', method: 'get', ...variables, signal });

export function getEmailBoxDetailsQuery(
  variables: GetEmailBoxDetailsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.EmailBoxDetailsDto>;
};

export function getEmailBoxDetailsQuery(
  variables: GetEmailBoxDetailsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.EmailBoxDetailsDto>)
    | reactQuery.SkipToken;
};

export function getEmailBoxDetailsQuery(
    variables: GetEmailBoxDetailsVariables | reactQuery.SkipToken,
) {
    return {
        queryKey: queryKeyFn({
            path: '/api/emailBoxes/{id}',
            operationId: 'getEmailBoxDetails',
            variables,
        }),
        queryFn:
      variables === reactQuery.skipToken
          ? reactQuery.skipToken
          : ({ signal }: QueryFnOptions) =>
              fetchGetEmailBoxDetails(variables, signal),
    };
}

export const useSuspenseGetEmailBoxDetails = <
  TData = Schemas.EmailBoxDetailsDto,
>(
        variables: GetEmailBoxDetailsVariables,
        options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EmailBoxDetailsDto,
      GetEmailBoxDetailsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
    ) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useSuspenseQuery<
    Schemas.EmailBoxDetailsDto,
    GetEmailBoxDetailsError,
    TData
  >({
      ...getEmailBoxDetailsQuery(deepMerge(fetcherOptions, variables)),
      ...options,
      ...queryOptions,
  });
};

export const useGetEmailBoxDetails = <TData = Schemas.EmailBoxDetailsDto,>(
    variables: GetEmailBoxDetailsVariables | reactQuery.SkipToken,
    options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EmailBoxDetailsDto,
      GetEmailBoxDetailsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
    const { queryOptions, fetcherOptions } = useEmailTamerApiContext(options);
    return reactQuery.useQuery<
    Schemas.EmailBoxDetailsDto,
    GetEmailBoxDetailsError,
    TData
  >({
      ...getEmailBoxDetailsQuery(
          variables === reactQuery.skipToken
              ? variables
              : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
  });
};

export type DeleteEmailBoxPathParams = {
  /**
   * @format uuid
   */
  id: string;
};

export type DeleteEmailBoxError = Fetcher.ErrorWrapper<undefined>;

export type DeleteEmailBoxVariables = {
  pathParams: DeleteEmailBoxPathParams;
} & EmailTamerApiContext['fetcherOptions'];

export const fetchDeleteEmailBox = (
    variables: DeleteEmailBoxVariables,
    signal?: AbortSignal,
) =>
    emailTamerApiFetch<
    undefined,
    DeleteEmailBoxError,
    undefined,
    {},
    {},
    DeleteEmailBoxPathParams
  >({ url: '/api/emailBoxes/{id}', method: 'delete', ...variables, signal });

export const useDeleteEmailBox = (
    options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteEmailBoxError,
      DeleteEmailBoxVariables
    >,
    'mutationFn'
  >,
) => {
    const { fetcherOptions } = useEmailTamerApiContext();
    return reactQuery.useMutation<
    undefined,
    DeleteEmailBoxError,
    DeleteEmailBoxVariables
  >({
      mutationFn: (variables: DeleteEmailBoxVariables) =>
          fetchDeleteEmailBox(deepMerge(fetcherOptions, variables)),
      ...options,
  });
};

export type QueryOperation =
  | {
      path: '/api/auth/user';
      operationId: 'getCurrentUser';
      variables: GetCurrentUserVariables | reactQuery.SkipToken;
    }
  | {
      path: '/api/backup';
      operationId: 'getMessagesThreads';
      variables: GetMessagesThreadsVariables | reactQuery.SkipToken;
    }
  | {
      path: '/api/backup/message';
      operationId: 'getMessageDetails';
      variables: GetMessageDetailsVariables | reactQuery.SkipToken;
    }
  | {
      path: '/api/backup/attachment';
      operationId: 'getMessageAttachment';
      variables: GetMessageAttachmentVariables | reactQuery.SkipToken;
    }
  | {
      path: '/api/backup/thread';
      operationId: 'getMessagesThread';
      variables: GetMessagesThreadVariables | reactQuery.SkipToken;
    }
  | {
      path: '/api/backup/folders';
      operationId: 'getFolders';
      variables: GetFoldersVariables | reactQuery.SkipToken;
    }
  | {
      path: '/api/emailBoxes';
      operationId: 'getEmailBoxes';
      variables: GetEmailBoxesVariables | reactQuery.SkipToken;
    }
  | {
      path: '/api/emailBoxes/{id}';
      operationId: 'getEmailBoxDetails';
      variables: GetEmailBoxDetailsVariables | reactQuery.SkipToken;
    };
